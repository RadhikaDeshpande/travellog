// Usage in your .js file
// jsonBuilder   = require(DEFS.DIR.JSON_BUILDER);  // Global Json Library Utility
// jBuilder      = new jsonBuilder();
//
// Notes :
//
// 1. The way DB returns the rows is dependent on the type of data set being returned.
//    -It can be simple data or complex, i.e single or mutiple types of rows and columns.
//    -Based on this type we need to access the rows in a unique way to access the data
//    Since we want to keep this builder generic, we have buildDBDataJSON function. 
//
// 2. For building custom JSON from non DB data anywhere in node we have added 
//    buildJson function. 
//
// 3. For various types of JSON type we have differnt builders
//    _typeSingleArrayMutipleObject, _typeSingleArraySingleObject , 
//    _typeMutipleArraySingleObject, _typeMutipleArrayMultipleObject. 
//
//    

/**
 * @param reqArray: json Builder Options 
 * @param onComplete: callback to pass the results JSON object(s) back
 */
var mongodb = require(DEFS.DIR.DB_CONNECT)('openshift_mongo'); // set global variable db connection

var jsonBuilder = function() {


  this.buildDBDataJSON = function(reqArray, uponComplete) {

      switch(reqArray.reqtype) {

        case DEFS.CONST.JSON_TYPE['singleArrayMultipleObj']:
        
          var inData = reqArray.reqData[0];
          var arrName = reqArray.arrayName;
          var isImage = reqArray.imageJson;

          _typeSingleArrayMultipleObject(inData, arrName, function(retJsonData) {
            if(isImage) {
              reqArray.jsonData = retJsonData;
              _mergeMongoImageJson(reqArray, function(mergedJsonData) {
                //SCUBE_LOG.info(mergedJsonData);
                uponComplete(mergedJsonData);
                return;
              });
            } else {
              SCUBE_LOG.info("JSON Builder UTIL Response");
              uponComplete(retJsonData);
              return;
            }
          });
        break; 

        case DEFS.CONST.JSON_TYPE['multiArrayMultipleObj']:

          _typeMultipleArrayMultipleObject(reqArray, function(retJsonData) {
            SCUBE_LOG.info("JSON Builder UTIL Response");
            uponComplete(retJsonData);
            return;
          });
        break;

        case DEFS.CONST.JSON_TYPE['singleArraySingleObj']:

           var inData = reqArray.reqData[0];
          _typeSingleArraySingleObject(inData, function(retJsonData) {
            SCUBE_LOG.info("JSON Builder UTIL Response");
            uponComplete(retJsonData);
            return;
          });

        break;

        default: //Ivalid case

        break;             
      }
  }

  this.buildJson = function(reqArray, onComplete) {

  }

  // Sample format
  // brand is the signle array having muliple objects
  /*     {
          brand: [  
           {
              brand_name: "Nike",
              brand_id: 2,
              scubit_count: 0 
           },
           {
              brand_name: "Addias",
              brand_id: 1,
              scubit_count: 0
            }
          ]
  */
  var _typeSingleArrayMultipleObject = function(rows, arrayName, callback) {

    var jsonData = {};
    var resArray = [];
     
    rows.forEach(function(row) {    // Loop through each row 

      var resObj = {};
      var keys = Object.keys(row);

      keys.forEach(function(key) { // Loop through each column
        var value = row[key];
        if(typeof value === 'string')
          resObj['' + key] = value.replace(/&amp;/g, '&');
        else
          resObj['' + key] = value;
      });
      resArray.push(resObj);
    });

    jsonData['' + arrayName] = resArray;
    callback(jsonData);
    return;
  }

  var _typeSingleArraySingleObject = function(inData, callback) {
    
    // We just need to send the object
    // Array is not needed as its signle json object 
    var jsonData = {};
    inData.forEach(function(row) {    // Loop through each row 
      var keys = Object.keys(row);
      keys.forEach(function(key) { // Loop through each column
        var value = row[key];
        jsonData['' + key] = value;
      });
    });
    callback(jsonData);
    return;
  }

  var _typeMultipleArraySingleObject = function(rows, arrayName, callback) {

  }

  var _typeMultipleArrayMultipleObject= function(reqArray, callback) {

    var jsonData = {};
    for (i = 0; i<reqArray.arrayLength; i++) { // Number of objects
      var resArray = [];
      reqArray.reqData[i].forEach(function(row) {  // Loop through each row 
        var resObj = {};
        var keys = Object.keys(row);
        keys.forEach(function(key) { // Loop through each column
          var value = row[key];
          resObj['' + key] = value;
        });
        resArray.push(resObj);
        jsonData['' + reqArray.arrayName[i]] = resArray;
      });        
    }
    callback(jsonData);
    return;
  }

  /* This function queries the mongo db to retriieve the 
     images, and merges to the original Json array */

  var _mergeMongoImageJson = function(reqArray, onComplete) {

    var queryIndexArray = [];
    var mongoDbimages = [];
    var oldJsonData = reqArray.jsonData;
    var arrName = reqArray.arrayName;
    var newJsonArray = [];
    var newJsonData = {};
    
    /* Get all the id's for this response*/
    oldJsonData[arrName].forEach(function(rows) {
      var keys = Object.keys(rows);
      keys.forEach(function(key) { // Loop through each column
        if(key === reqArray.imageName) {
          var value = rows[key];
          queryIndexArray.push(value);
        }
      });
    });

    /* Query mongo db for all the indices in queryIndexArray */
    var query1 = {};
    var query2 = {};
    query1["$in"] = queryIndexArray;
    query2[''+reqArray.imageName] = query1;

    //var cursor = dbConnectMongo.collection('tbl_brands_images').find({brand_id : {$in: [2,3]}});
    var cursor = dbConnectMongo.collection(reqArray.mongoTblName).find(query2);
    cursor.each(function(err, images) {
      if (images != null) {
        // Now need to merge the json data recieved here with the images array 
        mongoDbimages.push(images);    
      } else {
        // It sends last row as null so using it as callback for the
        // above for each loop.

        // For every id, get the corresponding images
        // Using images array since for a given id
        // we will have different image type id's
        oldJsonData[arrName].forEach(function(rows) {
          var imagesArray = [];
          mongoDbimages.forEach(function(image) {
            if(image[reqArray.imageName] == rows[reqArray.imageName]) {
              imagesArray.push(image['images']);
            }
          });
          rows['images'] = imagesArray;
          newJsonArray.push(rows);
        });
        newJsonData['' + arrName] = newJsonArray;
        onComplete(newJsonData);
        return;
      }
    });    
  }

  /* This function is now deprecated, since images are now done 
     in momgo db. But still keeping this code as a reference
  */
  var _buildImageJson = function(reqArray, onComplete) {

    /* Algorithm : 
    1. Iterate through the entire array set returned by DB
       and remove the duplicate entries, making a unique 
       array of objects per entity (mall, shop, etc)
    2. Copy the image_type_id and image_public_id from these entries
       and make a array of all image_id's associated with 
       a given entity(mall, shop, etc) and add it as an object for that entity
       in the unique array.
    3. In order to achieve this, maintain a hash with unique entity as key and its 
       array index in the final json object as the value.
    */
    var hash = {}; 
    var uniqueMallArr = [];
    var uniqueMallArrIndex = 0;
    var newJsonData = {};

    var oldJsonData = reqArray.jsonData;
    var arrName = reqArray.arrayName;
    var rowId = reqArray.rowId;

    oldJsonData[arrName].forEach(function(rows) {
      var tempMallObj = {};
      var tempImageObj = {};
      var tempImageArr = [];
      var keys = Object.keys(rows);
      if(rows[rowId] in hash) {  
      // If the id is already present copy only the image part 
        keys.forEach(function(key) { // Loop through each column
          if(key === 'image_type_id' || key === 'image_public_id') {
            var value = rows[key];
            tempImageObj['' + key] = value;
          }             
        });
        uniqueMallArr[hash[rows[rowId]]].images.push(tempImageObj);
      } else {
        // Its a new entry copy all the keys
        keys.forEach(function(key) { // Loop through each column
          if(key === 'image_type_id' || key === 'image_public_id') {
            var value = rows[key];
            tempImageObj['' + key] = value;
          } else {
            var value = rows[key];
            if(typeof value === 'string')
              tempMallObj['' + key] = value.replace(/&amp;/g, '&');
            else
              tempMallObj['' + key] = value;
          }
        });
        tempImageArr.push(tempImageObj);
        tempMallObj['images'] = tempImageArr;
        uniqueMallArr.push(tempMallObj);
        hash[rows[rowId]] = uniqueMallArrIndex;
        uniqueMallArrIndex++;
      }
    });
    newJsonData['' + arrName] = uniqueMallArr;
    onComplete(newJsonData);
  }
}
module.exports = jsonBuilder;
